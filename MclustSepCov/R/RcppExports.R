# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @name Mclust_SEP_each_cpp
#' @title The maximum likelihood estimation of the mixture distribution
#' @description Perform the EM algorithm for fitting the finite Gaussian mixture distribution with covariance separability.
#' @param Y Same as in \code{\link{Mclust_SEP_cpp}}.
#' @param p,q Same as in \code{\link{Mclust_SEP_cpp}}.
#' @param K A positive integer indicating the number of mixture components.
#' @param type_vari,type_time A character string indicating a structure of covariance factors, passed from \code{\link{Mclust_SEP_cpp}}. See `Details' for available options.
#' @param tol Same as in \code{\link{Mclust_SEP_cpp}}.
#' @param maxit Same as in \code{\link{Mclust_SEP_cpp}}.
#' @return A list with components:
#' \item{loglik}{The log-likelihood function.}
#' \item{df}{The degrees of freedom or the number of parameters of the mixture model.}
#' \item{BIC}{The Bayesian information crieteria.}
#' \item{K}{\code{K} from the input.}
#' \item{id_cluster}{Cluster membership of samples.}
#' \item{wt_cluster}{A matrix of dimension r-by-\code{K} whose row represents the maximum a posteriori of a sample.}
#' \item{EM_iter}{The number of iterations in the EM algorithm.}
#' \item{mu}{A matrix of the estimated mean whose row is the mean vector of a mixture component.}
#' \item{U,V}{A cube containing \code{K} slices of the estimated covariance matrix.}
#' \item{type_vari, type_time}{\code{type_vari}, \code{type_time} from the input.}
#' @details 
#' Cluster membership from 1 to \code{K} is randomly assigned to each sample.\cr\cr
#' \code{type_vari} specifies a type of the multivariable covariance \eqn{U_{p \times p}};
#' \itemize{
#'   \item Heteroscadatsic : \code{VVV} (unstructured)
#'   \item Homoscadatsic : \code{EEE} (unstructured)
#' }
#' and \code{type_time} the temporal covariance \eqn{V_{q\times q}};
#' \itemize{
#'   \item Heteroscadatsic :  \code{VUN} (unstructured), \code{VAR} (AR), \code{VCS} (CS) 
#'   \item Homoscadatsic :  \code{EUN} (unstructured), \code{EAR} (AR), \code{ECS} (CS)
#' }
#' @seealso \code{\link{Mclust_SEP_cpp}}
#' @examples
#' # Gaussian mixture model with two components
#' K <- 2
#' p <- 2
#' q <- 3
#' U <- lapply(1:K, function(noarg) getCovariance(p, 0.3, "AR"))
#' V <- lapply(1:K, function(noarg) getCovariance(q, 0.2, "CS"))
#' Sigma <- Map(kronecker, U, V) # separable covariance matrix
#' mu <- list(rep(0, p * q), 5 / sqrt(p*q) * rep(1, p * q)) # distinct mean vectors
#' Y <- vector(mode = "list", length = K)
#' for(i in 1:K){
#'   Y[[i]] <- mvtnorm::rmvnorm(n = 20, mean = mu[[i]], sigma = Sigma[[i]])
#' }
#' fit <- Mclust_SEP_each_cpp(Y = Reduce(rbind, Y), p = p, q = q, K = 2, type_vari = "EEE", type_time = "ECS")
#' @export
Mclust_SEP_each_cpp <- function(Y, p, q, K, type_vari, type_time, tol = 1e-4, maxit = 500L) {
    .Call('_MclustSepCov_Mclust_SEP_each_cpp', PACKAGE = 'MclustSepCov', Y, p, q, K, type_vari, type_time, tol, maxit)
}

#' @name getCovariance
#' @title Generate temporal covariance matrices
#' @description Return a covariance matrix with temporal structure.
#' @param q Dimension of a covariance matrix.
#' @param rho Temporal correlation in \eqn{(-1, 1)}. For \code{type='CS'}, \eqn{-1/\sqrt{q-1}} is a lower bound of \code{rho} for the returned matrix to be positive definite.
#' @param type A character string indicating one of types of temporal structure; autoregressive model if \code{type='AR'} and compound symmetry model if \code{type='CS'}. See `Details' for their structures.
#' @return A \code{q}-by-\code{q} temporal covariance matrix with diagonals 1.
#' @details Following temporal structures are available.
#' \enumerate{
#'   \item Autogressive structure: \eqn{V = \big(\rho^{|i-j|}; 1\le i,j \le q\big)}.
#'   \item Compound symmetry structure: \eqn{V = \big({\rm I}(i=j) + \rho {\rm I}(i \neq j); 1\le i,j \le q\big)}.
#' }
#' @examples
#' getCovariance(3, 0.3, "AR") # AR
#' getCovariance(3, 0.3, "CS") # CS
#'
#' # AR structure with heterogeneous variances
#' hvar <- c(1, 2, 3) # variances
#' diag(sqrt(hvar)) %*% getCovariance(3, 0.3, "AR") %*% diag(sqrt(hvar))
#' @export
getCovariance <- function(q, rho, type) {
    .Call('_MclustSepCov_getCovariance', PACKAGE = 'MclustSepCov', q, rho, type)
}

#' @name Optimization
#' @title Newton-Raphson's algorithm to find the optimal temporal correlation
#' @description Solve the constrained minimization problem using the log-barrier method to find the maximum likelihood estimator (MLE) of temporal correlation. The objective function is described in `Details'.
#' @param a A positive constant. See `Details'.
#' @param Z A matrix of sample vectors at row.
#' @param type A character string indicating a type of temporal covariance matrix. Available options are \code{'AR'} and \code{'CS'}.
#' @param rho0 An initial value for the temporal correlation coefficient. We empirically found that 0.001 works well for \code{type='AR'} and 0.5 for \code{type='CS'}.
#' @param lambda A positive constant multiplied to the log-barrier term. Default is 1.
#' @param maxit The maximum number for iterations. Default is 500.
#' @details The objective function is divided into two parts; the Gaussian log-likelihood function (up to constant multiplication) with mean 0 and covariance matrix \eqn{\Sigma = \Sigma(\rho)} and the log-barrier function. The former is written by 
#' \deqn{h(\rho; a, Z) = a \log|\Sigma| + {\rm tr}(\Sigma^{-1} S),}
#' where \eqn{a>0} and \eqn{S = Z^{\rm T} Z}, and the latter is
#' \deqn{b(\rho; u, l) = \log(u - \rho) + \log(\rho - l),}
#' where \eqn{u,l} is an upper and a lower bound of \eqn{\rho}, respectively. These quantities depend on \code{type} as follows;
#' \itemize{
#'   \item If \code{type='AR'}, \eqn{\Sigma= \big(\rho^{|i-j|}; 1\le i,j \le q\big)} and  \eqn{l=-1, u=1},
#'   \item if \code{type='CS'}, \eqn{\Sigma = \big({\rm I}(i=j) + \rho {\rm I}(i \neq j); 1\le i,j \le q\big)} and \eqn{l=-1/\sqrt{q-1}, u=1},
#' }
#' where \eqn{q=}\code{ncol(Z)}. The objective function is, hence,
#' \deqn{h(\rho; a, Z) - \lambda ~ b(\rho; u, l).}
#' @examples
#' q <- 10
#' # AR model
#' set.seed(6)
#' Y <- mvtnorm::rmvnorm(100, rep(0, q), getCovariance(q, 0.3, "AR"))
#' LB_algorithm_cpp(a = nrow(Y), Z = Y, rho0 = 1e-3, type = "AR")
#' 
#' # CS model
#' set.seed(6)
#' Y <- mvtnorm::rmvnorm(100, rep(0, q), getCovariance(q, 0.3, "CS"))
#' LB_algorithm_cpp(a = nrow(Y), Z = Y, rho0 = 1e-3, type = "CS")
#' @exports
LB_algorithm_cpp <- function(a, Z, type, rho0, lambda = 1.0, maxit = 500L) {
    .Call('_MclustSepCov_LB_algorithm_cpp', PACKAGE = 'MclustSepCov', a, Z, type, rho0, lambda, maxit)
}

